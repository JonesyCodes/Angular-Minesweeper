{"ast":null,"code":"import { EventEmitter } from '@angular/core';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common\";\nimport * as i2 from \"../grid-squares/grid-squares.component\";\nfunction GameGridComponent_app_grid_squares_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r4 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"app-grid-squares\", 4);\n    i0.ɵɵlistener(\"squareClickedEvent\", function GameGridComponent_app_grid_squares_3_Template_app_grid_squares_squareClickedEvent_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r4);\n      const idx_r2 = restoredCtx.index;\n      const ctx_r3 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r3.squareClicked(idx_r2));\n    })(\"squareRightClickedEvent\", function GameGridComponent_app_grid_squares_3_Template_app_grid_squares_squareRightClickedEvent_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r4);\n      const idx_r2 = restoredCtx.index;\n      const ctx_r5 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r5.squareRightClicked(idx_r2));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const s_r1 = ctx.$implicit;\n    i0.ɵɵproperty(\"data\", s_r1);\n  }\n}\nconst _c0 = function (a0) {\n  return {\n    \"grid-template-columns\": a0\n  };\n};\nconst _c1 = function (a0) {\n  return {\n    \"disabled\": a0\n  };\n};\nexport class GameGridComponent {\n  constructor() {\n    this.title = 'Minefield';\n    this.data = {\n      mines: 1,\n      columns: 5,\n      rows: 5,\n      flagOnClick: false\n    };\n    this.gameOverEvent = new EventEmitter();\n    this.flagEvent = new EventEmitter();\n    this.colArray = [];\n    this.rowArray = [];\n    this.squares = [];\n    this.revealedEmpty = 0;\n    this.gameOver = false;\n  }\n  ngOnInit() {\n    this.setDimension();\n    this.setColumns = `repeat(${this.data.columns}, 50px)`;\n  }\n  //// Generate grid and randomise bomb locations\n  setDimension() {\n    this.squares = [];\n    let totalSquares = this.data.rows * this.data.columns;\n    for (let i = 0; i < totalSquares; i++) {\n      if (i < this.data.mines) {\n        const squareData = {\n          mine: true,\n          state: 'hidden'\n        };\n        this.squares.push(squareData);\n      } else {\n        const squareData = {\n          mine: false,\n          state: 'hidden'\n        };\n        this.squares.push(squareData);\n      }\n    }\n    this.squares.sort(() => Math.random() - 0.5);\n    let index = 0;\n    this.squares.forEach(() => {\n      let adjacentSquares = [];\n      if (index % this.data.columns - 1 >= 0) {\n        adjacentSquares.push(index - 1);\n      }\n      ; // left\n      if (index % this.data.columns + 1 < this.data.columns) {\n        adjacentSquares.push(index + 1);\n      }\n      ; // right\n      if (index - this.data.columns >= 0) {\n        adjacentSquares.push(index - this.data.columns);\n      }\n      ; // top\n      if (index + this.data.columns < totalSquares) {\n        adjacentSquares.push(index + this.data.columns);\n      }\n      ; // bottom\n      if (index - this.data.columns - 1 >= 0 && index % this.data.columns - 1 >= 0) {\n        adjacentSquares.push(index - this.data.columns - 1);\n      }\n      ; // top left\n      if (index - this.data.columns + 1 >= 0 && index % this.data.columns + 1 < this.data.columns) {\n        adjacentSquares.push(index - this.data.columns + 1);\n      }\n      ; // top right\n      if (index + this.data.columns - 1 < totalSquares && index % this.data.columns - 1 >= 0) {\n        adjacentSquares.push(index + this.data.columns - 1);\n      }\n      ; // bottom left\n      if (index + this.data.columns + 1 < totalSquares && index % this.data.columns + 1 < this.data.columns) {\n        adjacentSquares.push(index + this.data.columns + 1);\n      }\n      ; // bottom right\n      this.squares[index].adjacent = adjacentSquares;\n      index++;\n    });\n  }\n  //// Recieves Event emitted from square, check adjacent squares for mines, if none found repeat for adjacent squares\n  squareClicked(index) {\n    let square = this.squares[index];\n    let adjacentMines = 0;\n    if (this.data.flagOnClick) {\n      this.squareRightClicked(index);\n      return;\n    }\n    if (square.state != 'hidden') {\n      return;\n    }\n    square.adjacent?.forEach(index => {\n      if (this.checkForMine(index)) {\n        adjacentMines++;\n      }\n    });\n    square = {\n      state: 'revealed',\n      mine: square.mine,\n      adjacentMines: adjacentMines,\n      adjacent: square.adjacent\n    };\n    this.squares[index] = square;\n    if (adjacentMines == 0) {\n      square.adjacent?.forEach(check => {\n        if (this.squares[check].state == 'hidden') {\n          this.squareClicked(check);\n        }\n      });\n    }\n    this.checkForWin(square);\n  }\n  //// Recieves Event emitted from square, adds/removes flag \n  squareRightClicked(index) {\n    let square = this.squares[index];\n    if (square.state == 'hidden') {\n      square = {\n        state: 'flagged',\n        mine: square.mine,\n        adjacentMines: square.adjacentMines,\n        adjacent: square.adjacent\n      };\n      this.squares[index] = square;\n      this.flagEvent.emit(true);\n    } else {\n      square = {\n        state: 'hidden',\n        mine: square.mine,\n        adjacentMines: square.adjacentMines,\n        adjacent: square.adjacent\n      };\n      this.squares[index] = square;\n      this.flagEvent.emit(false);\n    }\n  }\n  //// Checks if a square is a mine\n  checkForMine(index) {\n    let square = this.squares[index];\n    if (square.mine) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  //// Checks if the win/loss condition has been met\n  checkForWin(currentSquare) {\n    if (currentSquare.mine) {\n      this.gameOverEvent.emit(false);\n      this.gameOver = true;\n    } else {\n      this.revealedEmpty++;\n      if (this.revealedEmpty == this.data.columns * this.data.rows - this.data.mines) {\n        this.gameOverEvent.emit(true);\n      }\n    }\n  }\n}\nGameGridComponent.ɵfac = function GameGridComponent_Factory(t) {\n  return new (t || GameGridComponent)();\n};\nGameGridComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n  type: GameGridComponent,\n  selectors: [[\"app-game-grid\"]],\n  inputs: {\n    data: \"data\"\n  },\n  outputs: {\n    gameOverEvent: \"gameOverEvent\",\n    flagEvent: \"flagEvent\"\n  },\n  decls: 4,\n  vars: 7,\n  consts: [[1, \"gridComponent\"], [\"id\", \"gridDiv\"], [\"id\", \"minefield\", 1, \"grid\", 3, \"ngStyle\", \"ngClass\"], [3, \"data\", \"squareClickedEvent\", \"squareRightClickedEvent\", 4, \"ngFor\", \"ngForOf\"], [3, \"data\", \"squareClickedEvent\", \"squareRightClickedEvent\"]],\n  template: function GameGridComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵelementStart(0, \"div\", 0)(1, \"div\", 1)(2, \"div\", 2);\n      i0.ɵɵtemplate(3, GameGridComponent_app_grid_squares_3_Template, 1, 1, \"app-grid-squares\", 3);\n      i0.ɵɵelementEnd()()();\n    }\n    if (rf & 2) {\n      i0.ɵɵadvance(2);\n      i0.ɵɵproperty(\"ngStyle\", i0.ɵɵpureFunction1(3, _c0, ctx.setColumns))(\"ngClass\", i0.ɵɵpureFunction1(5, _c1, ctx.gameOver));\n      i0.ɵɵadvance(1);\n      i0.ɵɵproperty(\"ngForOf\", ctx.squares);\n    }\n  },\n  dependencies: [i1.NgClass, i1.NgForOf, i1.NgStyle, i2.GridSquaresComponent],\n  styles: [\".grid[_ngcontent-%COMP%]{display:grid;background-image:url(dirt2.ce556096d9d604e8.jfif);background-size:contain;border:4px ridge rgba(114,132,150,1);border-radius:5px;padding:5px;overflow-x:auto}.gridComponent[_ngcontent-%COMP%]{display:flex;flex-direction:column;align-items:center;margin:2vh 0 4vh}.disabled[_ngcontent-%COMP%]{pointer-events:none;opacity:.8}#gridDiv[_ngcontent-%COMP%]{max-width:100%}\"]\n});","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}